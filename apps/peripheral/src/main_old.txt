/*
 * Copyright (c) 2021 Nordic Semiconductor ASA
 * SPDX-License-Identifier: Apache-2.0
 */

#include <zephyr/kernel.h>
#include <zephyr/logging/log.h>
#include <zephyr/drivers/uart.h>
#include <zephyr/net/buf.h>
#include <draeger/netbuf_utils.h>
#include "api.pb.h"
#include <pb_decode.h>
#include <pb_encode.h>
#include <zephyr/sys/byteorder.h>

LOG_MODULE_REGISTER(main, CONFIG_APP_LOG_LEVEL);

#define RX_BUF_SIZE 255
NET_BUF_POOL_FIXED_DEFINE(pool, 100, RX_BUF_SIZE, 0, NULL);


//int old() {
//    int ret, err;
//
//    printk("Zephyr Example Application\n");
//
//    const struct gpio_dt_spec rts1_i_spec = GPIO_DT_SPEC_GET_OR(DT_NODELABEL(rts), i1_gpios, { 0 });
//    const struct gpio_dt_spec rts1_o_spec = GPIO_DT_SPEC_GET_OR(DT_NODELABEL(rts), o1_gpios, { 0 });
//    const struct gpio_dt_spec rts2_i_spec = GPIO_DT_SPEC_GET_OR(DT_NODELABEL(rts), i2_gpios, { 0 });
//    const struct gpio_dt_spec rts2_o_spec = GPIO_DT_SPEC_GET_OR(DT_NODELABEL(rts), o2_gpios, { 0 });
//
//    if (!gpio_is_ready_dt(&rts1_i_spec)) {
//        LOG_ERR("RTS1 is not ready");
//        return 0;
//    }
//    if (!gpio_is_ready_dt(&rts2_i_spec)) {
//        LOG_ERR("RTS2 is not ready");
//        return 0;
//    }
//
//    gpio_pin_configure_dt(&rts1_i_spec, GPIO_INPUT);
//    gpio_pin_configure_dt(&rts1_o_spec, GPIO_OUTPUT);
//    gpio_pin_configure_dt(&rts2_i_spec, GPIO_INPUT);
//    gpio_pin_configure_dt(&rts2_o_spec, GPIO_OUTPUT);
//
//    int oldRTS1 = -1;
//    int oldRTS2 = -1;
//
//    while (true) {
//        int rts1 = gpio_pin_get_dt(&rts1_i_spec);
//        int rts2 = gpio_pin_get_dt(&rts2_i_spec);
//
//        if (rts1 != oldRTS1) {
//            printk("RTS1 %d -> %d\n", oldRTS1, rts1);
//            oldRTS1 = rts1;
//            gpio_pin_set_dt(&rts1_o_spec, rts1);
//        }
//        if (rts2 != oldRTS2) {
//            printk("RTS2 %d -> %d\n", oldRTS2, rts2);
//            oldRTS2 = rts2;
//            gpio_pin_set_dt(&rts2_o_spec, rts2);
//        }
//
////        k_sleep(K_USEC(10));
//    }
//
//    return 0;
//
//}

#define CRC16_SEED	0xFFFF
#define CRC16_XOR_VALUE 0x0000
#define HEADER_SIZE sizeof(uint16_t) + sizeof(uint16_t) + sizeof(uint16_t)

#define UART_TIMEOUT 200
struct net_buf *mainBuf;
uint8_t uart_buf[RX_BUF_SIZE] = {0};


static void uart_cb(const struct device *dev, struct uart_event *event, void *user_data) {

    switch (event->type) {
        case UART_TX_DONE:
            break;
        case UART_TX_ABORTED:
            break;
        case UART_RX_RDY: {
            struct uart_event_rx *const rx_event = &event->data.rx;

            struct net_buf *buf = net_buf_alloc_len(&pool, RX_BUF_SIZE, K_NO_WAIT);
            if (!buf) {
                LOG_ERR("Failed to allocate UART RX buffer");
                break;
            }

            net_buf_add_mem(buf, rx_event->buf + rx_event->offset, rx_event->len);
            net_buf_frag_add(mainBuf, buf);

//            LOG_INF("UART_RX_RDY %d, %d", rx_event->len, rx_event->offset);
            break;
        }
        case UART_RX_BUF_REQUEST:
//            printk("UART_RX_BUF_REQUEST\n");
            break;
        case UART_RX_BUF_RELEASED:
//            printk("UART_RX_BUF_RELEASED\n");
            break;
        case UART_RX_DISABLED:
//            printk("UART_RX_DISABLED\n");
            uart_rx_enable(dev, uart_buf, sizeof(uart_buf), UART_TIMEOUT);
            break;
        case UART_RX_STOPPED:
//            printk("UART_RX_STOPPED\n");
            break;
    }
}


void HandleRequestPing(RequestPing *request, ResponsePing *response) {
    strcpy(response->payload, request->payload);
}


int processBuffer(const struct device *uart) {
    if (net_buf_frags_len(mainBuf) < 6) {
        return -1;
    }

    uint16_t receivedCRC;
    if (net_buf_pull_across_fragments_le16(&mainBuf, &receivedCRC)) {
        return -2;
    }

    uint16_t sequenceNumber;
    if (net_buf_pull_across_fragments_le16(&mainBuf, &sequenceNumber)) {
        return -2;
    }

    uint16_t payloadSize;
    if (net_buf_pull_across_fragments_le16(&mainBuf, &payloadSize)) {
        return -2;
    }

    while (true) {
        if (net_buf_frags_len(mainBuf) < payloadSize) {
            k_sleep(K_MSEC(1));
            continue;
        }

        uint8_t requestPayload[payloadSize];
        if (net_buf_pull_across_fragments(&mainBuf, requestPayload, payloadSize)) {
            LOG_ERR("Failed to pull payload from buffer. (%d bytes)", payloadSize);
            return -3;
        }

        const uint16_t calculatedCRC = crc16_itu_t(CRC16_SEED, requestPayload, payloadSize) ^ CRC16_XOR_VALUE;
        if (receivedCRC != calculatedCRC) {
            LOG_WRN("Invalid CRC: received=%d, calculated=%d", receivedCRC, calculatedCRC);
            return -4;
        }

        LOG_INF("Handling request of size %d", payloadSize);

        // Deserialize buffer
        RequestAPI request = RequestAPI_init_zero;
        pb_istream_t stream = pb_istream_from_buffer(requestPayload, payloadSize);
        if (!pb_decode(&stream, RequestAPI_fields, &request)) {
            LOG_WRN("Failed to decode pb request");
            return -5;
        }

        ResponseAPI  response = ResponseAPI_init_zero;

        if (request.has_ping) {
            HandleRequestPing(&request.ping, &response.ping);
            response.has_ping = true;
        }

        uint8_t responsePayload[HEADER_SIZE + 512] = {0};

        pb_ostream_t outStream = pb_ostream_from_buffer(responsePayload + HEADER_SIZE, sizeof(responsePayload) - HEADER_SIZE);

        if (!pb_encode(&outStream, ResponseAPI_fields, &response)) {
            LOG_ERR("Failed to encode pb response");
            return -6;
        }

        // Fill header
        uint16_t crc = sys_cpu_to_le16(crc16_itu_t(CRC16_SEED, responsePayload + HEADER_SIZE, outStream.bytes_written) ^ CRC16_XOR_VALUE);
        responsePayload[0] = crc & 0xFF;
        responsePayload[1] = (crc >> 8) & 0xFF;
        responsePayload[2] = sys_cpu_to_le16(sequenceNumber) & 0xFF;
        responsePayload[3] = (sys_cpu_to_le16(sequenceNumber) >> 8) & 0xFF;
        responsePayload[4] = sys_cpu_to_le16(outStream.bytes_written) & 0xFF;
        responsePayload[5] = (sys_cpu_to_le16(outStream.bytes_written) >> 8) & 0xFF;

        if (uart_tx(uart, responsePayload, outStream.bytes_written + HEADER_SIZE, SYS_FOREVER_US)) {
            LOG_ERR("Failed to TX response via UART");
            return -7;
        }

        break;
    }

    return 0;
}


int main_xxx(void) {
    int err;

    LOG_INF("Running main...");

    const struct device *uart = DEVICE_DT_GET(DT_NODELABEL(uart0));
    mainBuf = net_buf_alloc_len(&pool, RX_BUF_SIZE, K_NO_WAIT);

    const struct uart_config uart_cfg = {
            .baudrate = 115200,
            .parity = UART_CFG_PARITY_NONE,
            .stop_bits = UART_CFG_STOP_BITS_1,
            .data_bits = UART_CFG_DATA_BITS_8,
            .flow_ctrl = UART_CFG_FLOW_CTRL_RTS_CTS,
    };

    uart_configure(uart, &uart_cfg);

    if (!device_is_ready(uart)) {
        printk("UART is not ready.\n");
        return -1;
    }

    err = uart_callback_set(uart, uart_cb, NULL);
    if (err) {
        printk("Failed to set UART callback.\n");
        return -2;
    }

    uart_rx_enable(uart, uart_buf, sizeof(uart_buf), UART_TIMEOUT);

    while (true) {
        processBuffer(uart);
        k_sleep(K_MSEC(1));
    }

    return 0;
}

